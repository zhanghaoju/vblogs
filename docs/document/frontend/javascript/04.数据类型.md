---
title: 数据类型
date: 2022-09-16
---

## Number

### 基础概念

#### 整数和浮点数

JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，`1`与`1.0`是相同的，是同一个数

```javascript
console.log(1 === 1.0) // true
```

JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）

注意：浮点数不是精确的值，最可靠的方法是使用`toFixed()`进行结果的舍入

```javascript
console.log(0.1 + 0.2 === 0.3); // 返回false
	// -0与0
console.log(-0 === +0); // true
```

#### 数值精度

JavaScript中大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以可以理解为JavaScript 对15位的十进制数都可以精确处理。

```javascript
console.log(Math.pow(2, 53))// 9007199254740992
// 多出的三个有效数字，将无法保存
console.log(9007199254740992111) // 9007199254740992000
```

#### 数值范围

64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示，会返回`Infinity`(无穷大)

```javascript
console.log(Math.pow(2, 1024))// Infinity
```

如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。

```javascript
console.log(Math.pow(2, -1075))// 0
```

JavaScript提供number对象的MAX_VALUE  和 MIN_VALUE属性，返回可以表示具体的最大值和最小值

```javascript
	console.log(Number.MAX_VALUE); // 1.7976931348623157e+308
	console.log(Number.MIN_VALUE); // 5e-324sa
```

#### 数值表示法

- JavaScript会自动将数值转为科学计数法表示

```javascript
console.log(1234567890123456789012); // 1.2345678901234568e+21
```

- 默认情况 JavaScript会将八进制、十六进制、二进制转为十进制

```javascript
console.log(0xff); // 255
```

- 可以通过在数字后面附加字母"`e`"，并指定零的数量来缩短数字

```javascript
let billion = 1e9; // 10亿 字面意思：数字1后面跟9个0
// 换句话说 "e"把数字乘以1后面跟着给定数量0的数字
// 1e3 = 1 * 1000
// 123e6 = 123000000
// 1微秒(百万分之一秒)：
let ms = 0.000001
// 使用"e"来完成
let ms = 1e-6; // 1左边有6个0
// 换句话说，e后面的负数除以1后面跟着给定数量的0的数字
// 1e-3 = 1 / 1000(=0.001) | -3 除以1后面跟着3个0的数字
// 1.23e-6 = 1.23 / 1000000 (=0.00000123) | -6 除以1后面跟着给定数量0的数字
```

### 特殊数值

#### 正零和负零

JavaScript 内部实际上存在2个`0`：一个是`+0`，一个是`-0`，区别就是64位浮点数表示法的符号位不同。它们是等价的。

```javascript
console.log(-0 === +0) // true
console.log(0 === -0) // true
console.log(0 === +0) // true
```

一般情况下都会将正零和负零作为正常`0`，只有再`+0`和`-0`作为分组的时候，返回的值是不相等的

```javascript
console.log((1 / +0) === (1 / -0)) // false
```

#### NaN

`NaN`是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。

它是一个不正确的或者一个未定义的数学操作所得到的结果

```javascript
	console.log("not a number" / 2); // NaN
	// NaN是粘性的，任何对NaN的进一步操作都会返回NaN
	console.log('not a number' / 2 + 5); // NaN
  // 在ECMAScript中，0、-0和+0相除都会返回NaN
  console.log(0/0)// NaN
  console.log(-0/+0)// NaN
  // NaN不等于包括NaN在内的任何值，比如下面的比较会返回false
  console.log(NaN==NaN)
```

#### Infinity

- `Infinity`表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到`Infinity`。

```javascript
console.log(Math.pow(2, 1024))// Infinity
console.log(0 / 0) // NaN
console.log(1 / 0) // Infinity
```

- `Infinity`有正负之分，`Infinity`表示正的无穷，`-Infinity`表示负的无穷。

```javascript
console.log(Infinity === -Infinity) // Infinity
console.log(1 / -0) // -Infinity
console.log(-1 / -0) // Infinity
```

非零正数除以`-0`，会得到`-Infinity`，负数除以`-0`，会得到`Infinity`。

- `Infinity`与`NaN`比较，总是返回`false`。

```javascript
console.log(Infinity > NaN) // false
console.log(-Infinity > NaN) // false
console.log(Infinity < NaN) // false
console.log(-Infinity < NaN) // false
```

##### 运算规则

- `Infinity`的四则运算，符合无穷的数学计算规则。

```javascript
5 * Infinity // Infinity
5 - Infinity // -Infinity
Infinity / 5 // Infinity
5 / Infinity // 0
```

- 0乘以`Infinity`，返回`NaN`；0除以`Infinity`，返回`0`；`Infinity`除以0，返回`Infinity`。

```javascript
0 * Infinity // NaN
0 / Infinity // 0
Infinity / 0 // Infinity
```

- `Infinity`加上或乘以`Infinity`，返回的还是`Infinity`。

```javascript
Infinity + Infinity // Infinity
Infinity * Infinity // Infinity
```

- `Infinity`减去或除以`Infinity`，得到`NaN`。

```javascript
Infinity - Infinity // NaN
Infinity / Infinity // NaN
```

- `Infinity`与`null`计算时，`null`会转成0，等同于与`0`的计算。

```javascript
null * Infinity // NaN
null / Infinity // 0
Infinity / null // Infinity
```

- `Infinity`与`undefined`计算，返回的都是`NaN`。

```javascript
undefined + Infinity // NaN
undefined - Infinity // NaN
undefined * Infinity // NaN
undefined / Infinity // NaN
Infinity / undefined // NaN
```

### 与数值相关的全局方法

#### parseInt

##### 基础语法

- `parseInt`用于将字符串转换为整数，并且会自动将字符串进行转换为数值类型

```javascript
console.log(typeof (parseInt('123.2'))) // number
```

- 自动清空字符串头部的空格

```javascript
console.log(parseInt('    123.2')) // 123
```

- 如果字符串的第一个字符不能转换为数字，则返回NaN，否则只返回已经转换好的部分数值

```javascript
console.log(parseInt('12.5em')) // 12
console.log(parseInt('w12.5em')) // NaN
```

- 如果字符串以`0x`或`0X`开头，`parseInt`会将其按照十六进制数解析。如果已`0`开头按照十进制解析

```javascript
console.log(parseInt('0x10')) // 16
console.log(parseInt('010')) // 10
```

##### 进制转换

`parseInt(str,radix) `的第二个参数指定了数字系统的基数，因此`parseInt`还可以解析十六进制、二进制相等的字符串

```javascript
console.log(parseInt('0xff', 16)); // 255
// 没有 0x 仍然有效 如果提供了十六进制数，那么字符串前面的"0X"可以省略
console.log(parseInt('ff', 16)); // 255
console.log(parseInt('2n9c', 36)); // 123456
```

#### parseFloat

- `parseFloat`将一个字符串转换为浮点数，如果符合科学计数法，则会将其进行转换后显示

```javascript
console.log(parseFloat('3.14')) // 3.14
console.log(parseFloat('314e-2')) // 3.14
console.log(parseFloat('0.0314E+2')) // 3.14
```

- 如果字符串中包含不能转为浮点数的数值，只返回已经转好的部分

```javascript
console.log(parseFloat('3.142rem32')) // 3.142
```

- 与`parseInt`一样会过滤前置空格，如果第一个字符不能转换则返回`NaN`
- `parseFloat`会将空字符串转为`NaN`

```javascript
console.log(parseFloat('')) // NaN
```

##### parseFloat与Number的转换区别

```javascript
console.log(parseFloat(true)) // NaN
console.log(Number(true)) // 1
console.log(parseFloat(null))// NaN
console.log(Number(null))// 1
console.log(parseFloat(''))// NaN
console.log(Number(''))// 0
console.log(parseFloat('123.45#')) // 123.45
console.log(Number('123.45#'))// NaN
```

#### isNaN

```
isNaN`方法可以用来判断一个值是否为`NaN
```

- 只对数值有效，当传入其他值，例如字符串的时候会先进行转换，字符串会被转换为`NaN`

```javascript
console.log(isNaN(NaN)) // true
console.log(isNaN(1)) // false
console.log(isNaN('test')) // true
```

- 对于对象和数组，`isNaN`也返回`true`，对于空数组或者只有一个数值成员的数组会返回`false`，因为这些数组能被`Number`转成数值

```javascript
console.log(isNaN({})) // true
console.log(isNaN(['zhj'])) // true
console.log(isNaN([])) // false
console.log(isNaN([123])) // false
```

#### isFinite

`isFinite`方法返回一个布尔值，表示某个值是否为正常的数值。

```javascript
	console.log(isFinite(Infinity)); // false
	console.log(isFinite(-Infinity)); // false
	console.log(isFinite(NaN)); // false
	console.log(isFinite(undefined)); // false
	console.log(isFinite(null)); // true
	console.log(isFinite("24")) // true
```

### 实例方法

#### toString()

用来将一个值转换为字符串形式

```javascript
console.log((10).toString()) // 10
let str = (10).toString()
console.log(typeof (str)) // string
```

#### toFixed()

将一个数转为指定位数的小数，然后返回这个小数对应的字符串

```javascript
let str = (10.234).toFixed(2)
console.log(str) // 10.23
```

注意：`toFixed()`方法的参数为小数位数，有效范围为0到100，超出这个范围将抛出 RangeError 错误。

#### toExponential()

将一个数转为科学计数法形式

```javascript
let str = (10).toExponential()
console.log(str) // 1e+1
```

注意：`toExponential`方法的参数是小数点后有效数字的位数，范围为0到100，超出这个范围，会抛出一个 RangeError 错误。

#### toPrecision()

将一个数转为指定位数的有效数字

```javascript
let str1 = (10.234).toPrecision(1)
let str2 = (10.234).toPrecision(2)
console.log(str1) // 1e+1
console.log(str2) // 12
```

#### toLocaleString()

接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式。

```javascript
let local = (123).toLocaleString('zh-Hans-CN-u-nu-hanidec')
console.log(local) // 一二三
```

该方法还可以接受第二个参数配置对象，用来定制指定用途的返回字符串。该对象的`style`属性指定输出样式，默认值是`decimal`，表示输出十进制形式。如果值为`percent`，表示输出百分数。

```javascript
let local = (123).toLocaleString('zh-Hans-CN', { style: 'percent' })
console.log(local) // 12,300%
```

如果`style`属性的值为`currency`，则可以搭配`currency`属性，输出指定格式的货币字符串形式。

```javascript
let local = (123).toLocaleString('zh-Hans-CN', { style: 'currency', currency: 'CNY' })
console.log(local) // ¥123.00
```

## BigInt

### 基础知识

JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。

- 一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示，这使得 JavaScript 不适合进行科学和金融方面的精确计算。
- 二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回`Infinity`。

```javascript
// 超过 53 个二进制位的数值，无法保持精度
console.log(Math.pow(2, 53) === Math.pow(2, 53) + 1) // true
// 超过 2 的 1024 次方的数值，无法表示
console.log(Math.pow(2, 1024)) // Infinity
```

[ES2020](https://github.com/tc39/proposal-bigint) 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。

注意：BigInt 类型的数据必须添加后缀`n`

```javascript
const a = 2172141653n;
const b = 15346349309n;
// BigInt 可以保持精度
console.log(a * b) // 33334444555566667777n
// 普通整数无法保持精度
console.log(Number(a) * Number(b)) // 33334444555566670000
```

- BigInt 同样可以使用各种进制表示，都要加上后缀n

```javascript
console.log(0b1101n) // 13n 二进制
console.log(0o777n)// 511n 八进制
console.log(0xFFn)// 255n 十六进制
```

- BigInt 与普通整数是两种值，它们之间并不相等

```javascript
console.log(42n === 42) // false
```

- `typeof`运算符对于 BigInt 类型的数据返回`bigint`

```javascript
console.log(typeof 123n) // bigint
```

- BigInt 可以使用负号（`-`），但是不能使用正号（`+`），因为会与 asm.js 冲突

```javascript
console.log(-42n) // 正确 -42n
console.log(+42n) // 报错
```

JavaScript 以前不能计算70的阶乘（即`70!`），因为超出了可以表示的精度。

```javascript
let p = 1;
for (let i = 1; i <= 70; i++) {
  p *= i;
}
console.log(p); // 1.197857166996989e+100
```

现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。

```javascript
let p = 1n;
for (let i = 1n; i <= 70n; i++) {
  p *= i;
}
console.log(p); // 11978571...00000000n
```

### BigInt函数

JavaScript 原生提供`BigInt`函数，可以用它生成 BigInt 类型的数值。转换规则基本与`Number()`一致，将其他类型的值转为 BigInt。

```javascript
console.log(BigInt(123)) // 123n
console.log(BigInt('123')) // 123n
console.log(BigInt(false)) // 0n
console.log(BigInt(true)) // 1n
```

- `BigInt()`函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错

```javascript
console.log(new BigInt()) // TypeError
console.log(BigInt(undefined)) //TypeError
console.log(BigInt(null)) // TypeError
console.log(BigInt('123n')) // SyntaxError
console.log(BigInt('abc')) // SyntaxError
```

注意：字符串`123n`无法解析成 Number 类型，所以也会报错

- 参数如果是小数，也会报错

```javascript
console.log(BigInt(1.5)) // RangeError
console.log(BigInt('1.5')) // SyntaxError
```

BigInt 继承了 Object 对象的两个实例方法。

- `BigInt.prototype.toString()`
- `BigInt.prototype.valueOf()`

它还继承了 Number 对象的一个实例方法。

- `BigInt.prototype.toLocaleString()`

此外，还提供了三个静态方法。

- `BigInt.asUintN(width, BigInt)`： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。
- `BigInt.asIntN(width, BigInt)`：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。
- `BigInt.parseInt(string[, radix])`：近似于`Number.parseInt()`，将一个字符串转换成指定进制的 BigInt。

```javascript
const max = 2n ** (64n - 1n) - 1n;
console.log(BigInt.asIntN(64, max)) // 9223372036854775807n
console.log(BigInt.asIntN(64, max + 1n)) // -9223372036854775808n
console.log(BigInt.asUintN(64, max + 1n)) // 9223372036854775808n
```

`max`是64位带符号的 BigInt 所能表示的最大值。如果对这个值加`1n`，`BigInt.asIntN()`将会返回一个负值，因为这时新增的一位将被解释为符号位。而BigInt.asUintN()方法由于不存在符号位，所以可以正确返回结果



如果`BigInt.asIntN()`和`BigInt.asUintN()`指定的位数，小于数值本身的位数，那么头部的位将被舍弃

```javascript
const max = 2n ** (64n - 1n) - 1n;

console.log(BigInt.asIntN(32, max)) // -1n
console.log(BigInt.asUintN(32, max)) // 4294967295n
```

上面代码中，`max`是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃



于二进制数组，BigInt 新增了两个类型`BigUint64Array`和`BigInt64Array`，这两种数据类型返回的都是64位 BigInt。`DataView`对象的实例方法`DataView.prototype.getBigInt64()`和`DataView.prototype.getBigUint64()`，返回的也是 BigInt。



### 转换规则

可以使用`Boolean()`、`Number()`和`String()`这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。

```javascript
console.log(Boolean(0n)) // false
console.log(Boolean(1n)) // true
console.log(Number(1n)) // 1
console.log(String(1n))  // "1"
```

取反运算符（`!`）也可以将 BigInt 转为布尔值

```javascript
console.log(!0n) // true
console.log(!1n) // false
```

### 数学运算

数学运算方面，BigInt 类型的`+`、`-`、`*`和`**`这四个二元运算符，与 Number 类型的行为一致。除法运算`/`会舍去小数部分，返回一个整数。

```javascript
9n / 5n
// 1n
```

几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。

- 不带符号的右移位运算符`>>>`
- 一元的求正运算符`+`

上面两个运算符用在 BigInt 会报错。前者是因为`>>>`运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符`>>`。后者是因为一元运算符`+`在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定`+1n`会报错。

BigInt 不能与普通数值进行混合运算。

```javascript
1n + 1.3 // 报错
```

上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如`(2n**53n + 1n) + 0.5`这个表达式，如果返回 BigInt 类型，`0.5`这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。

同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。

```javascript
// 错误的写法
Math.sqrt(4n) // 报错

// 正确的写法
Math.sqrt(Number(4n)) // 2
```

上面代码中，`Math.sqrt`的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用`Number`方法转一下类型，才能进行计算。

asm.js 里面，`|0`跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与`|0`进行运算会报错。

```javascript
1n | 0 // 报错
```

### 其他运算

BigInt 对应的布尔值，与 Number 类型一致，即`0n`会转为`false`，其他值转为`true`。

```javascript
if (0n) {
  console.log('if');
} else {
  console.log('else');
}
// else
```

上面代码中，`0n`对应`false`，所以会进入`else`子句。

比较运算符（比如`>`）和相等运算符（`==`）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。

```javascript
0n < 1 // true
0n < true // true
0n == 0 // true
0n == false // true
0n === 0 // false
```

BigInt 与字符串混合运算时，会先转为字符串，再进行运算。

```javascript
console.log('' + 123n) // "123"
```

 ## String

### 基础内容

#### 基本包装类型

把简单数据类型，包装成为复杂数据类型，这样基本数据类型有了属性和方法

```javascript
let str = 'karim';
console.log(str.length);
```

#### 内部的操作

```javascript
	// （1）把简单数据类型包装为复杂数据类型
	var temp = String('karim');
	// （2）把临时变量的值给 str
	str = temp;
	// （3）销毁这个临时变量
	temp = null;
```

#### 默认只能写在一行内，否则会报错

```javascript
console.log('a
b
c')// 报错
```

#### 可以包含在单引号、双引号或反引号中三种方式中

1.  双引号："Hello" 
2. JSON.stringify 单引号：'Hello' 
3. 反引号：Hello

- 单引号字符串内部可以使用双引号，双引号的内部可以使用单引号

```javascript
	console.log('key = "value"'); // key = "value"
	// 单引号字符串的内部使用单引号需要在内部的单引号前面加上反斜杠，用来转义。双引号内部引用双引号同理
	console.log('Did she say \'hello\''); // Did she say 'hello'
	// 双引号和单引号都是"简单"引用，在JavaScript中两者几乎没有什么差别。
```

- 双引号和单引号都是"简单"引用，在JavaScript中两者几乎没有什么差别。

```javascript
	// 反引号是功能扩展引导。允许我们通过${...}将任何表达式嵌入到字符串中
	function sum(a, b) {
		return a + b;
	}
	console.log(`1 + 2 = ${sum(1, 2)}`) // 1 + 2 = 3
	// 使用反引号的另一个优点是它们允许字符串跨行
	let guestList = `Guests:
  * John
  * Pete
  * Mary
  `;
	console.log(guestList)
```

#### 字符串拼接

使用连接运算符`+`可以连接多个单行字符串，字符串+任何类型 = 拼接之后的新字符串【数值相加，字符相连】

```javascript
	console.log('沙漠' + '骆驼'); // 沙漠骆驼
	console.log('alan' + 18); // alan18
	console.log(12 + 14); // 26
```

### 特殊字符

#### 换行符

如果要将字符串分成多行显示，需要在每一行尾部使用`\n`

```javascript
var longString = 'long\
nLong\
nlong\
nstring'
console.log(longString); // longnLongnlongnstring
```

#### 转义符

反斜杠`(\)`在字符串中有特殊含义，用来表示一些特殊字符，又称为转义符

```javascript
	// 反斜杠（\）在字符串中有特殊含义，用来表示一些特殊字符，又称为转义符
	// 如果想要在字符串中插入一个分号
	console.log('I\'m the Walrus!'); // I'm the Walrus!
	// 由于只有与外部闭合引号相同的引号才需要转义。因此我们也可以使用反引号
	console.log(`I'm the Walrus!`); // I'm the Walrus!
	// 如果想要输出实际的反斜杠
	console.log(`\\`); // \
```

#### unicode示例

```javascript
	console.log("\u00A9"); // ©
	console.log("\u{20331}"); // 佫，罕见的中国象形文字（长 unicode）
	console.log("\u{1F60D}"); // 😍，笑脸符号（另一个长 unicode）
```

### 字符串与数组

字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）或者调用`str.charAt(pos)`方法返回

```javascript
let str = 'Hello';
// 对字符串直接使用[]方括号运算符
console.log(str[0]) // H
console.log(str.charAt(0)) // H
// 最后一个字符
console.log(str[str.length - 1]); // o
let st = 'Hello';
console.log(str[1000]);// undefined
console.log(str.charAt(1000));// 空字符串
```

他们两个唯一的区别是，`[]`超过数组长度会返回undefined，而`charAt`返回一个空字符串



注意：无法通过数组的方式去改变字符串

#### 字符串的长度

length属性返回字符串的长度，该属性也是无法改变的

```javascript
	let src = 'hello';
	console.log(s.length); // 5
	console.log(s.length = 3); // 3
	console.log(s.length); // 5
```

注意：`src.length`是一个数字属性，不是函数，不需要在后面加括号

#### 字符串的不可变性

字符串声明之后是不可变的，要修改某个变量的中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量

```javascript
let str = 'Hi';
str[0] = 'h';
console.log(str[0]); // H 字符串未改变
// 通常我们创建一个新的字符串，并将其分配给str而不是以前的字符串
str = 'h' + str[1]; // 替换字符串
console.log(str); // hi
```

#### 改变大小写

使用toLowerCase() 和 toUpperCase() 方法可以改变字符串大小写

```javascript
alert('Interface'.toUpperCase()); // INTERFACE
alert('Interface'.charAt(0).toLowerCase());// i
alert('BASE'.toLowerCase()); // base
```

### Base64转码

所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、`+`和`/`这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。

#### `btoa()`和`atob()`转码

JavaScript原生提供了两个Base64相关的方法

- `btoa()`：任意值转为 Base64 编码
- `atob()`：Base64 编码转为原来的值

```javascript
	let string = 'Hello World!';
	console.log(btoa(string)); // "SGVsbG8gV29ybGQh"
	// atob() Base64编码转为原来的值
	console.log(atob('SGVsbG8gV29ybGQh')); // Hello World!
```

注意：这两个方法不适合`ASCII`码的字符

```javascript
console.log(btoa('你好')) // 报错
```

#### 非ASCII码字符转换

要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。

```javascript
	function b64Encode(str) {
		return btoa(encodeURIComponent(str));
	}

	function b64Decode(str) {
		return decodeURIComponent(atob(str));
	}
	console.log(b64Encode('你好')); // JUU0JUJEJUEwJUU1JUE1JUJE

	console.log(b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE')); // 你好
```

### 查找字符串

#### indexOf()

它从给定位置的pos开始，在str中查找substr，如果没有找到就返回-1，否则返回匹配的位置

##### 语法

```javascript
str.indexOf(substr,pos)
let str1 = 'Widget with id';
alert(str1.indexOf('Widget'));// 0, 因为 'Widget' 一开始就被找到
alert(str1.indexOf('widget')); // -1，没有找到，检索是大小写敏感的
alert(str1.indexOf("id")); // 1，"id" 在位置 1 处（……idget 和 id）
// 第二个参数允许我们从给定的起始位置开始检索，例如，"id" 第一次出现的位置是 1。查询下一个存在位置时，我们从 2 开始检索
let str2 = 'Widget with id';
alert(str2.indexOf('id', 2)) // 12
```

- 返回所有的字符串位置，可以使用循环进行遍历，每一次新的调用都是在上一次调用之后

```javascript
let str3 = 'abacdeafghijk';
let target = 'a';
let pos = 0;
 while (true) {
 let fountPos = str3.indexOf(target, pos);
 if (fountPos == -1) {
 break;
 }
 console.log(`Found at ${fountPos}`); // 0 2 6
 // 继续从下一个位置查找
 pos = fountPos + 1
}

// 简写方式
let pos = -1;
while ((pos = str3.indexOf(target, pos + 1)) != -1) {
	console.log(pos) // 0 2 6
}
```

#### lastIndexOf

str.lastIndexOf(substr,pos); 从字符串的末尾开始搜索到开头

#### includes

str.includes(substr,pos) 根据str中是否包含substr来返回true/false

```javascript
console.log('Widget with id'.includes('Widget')); // true
console.log('Hello World'.includes('isYes')); // false
// str.includes(substr,pos)第二个参数是可选参数：开始位置的起始位置
console.log('Midget'.includes('id')); // true
console.log('Midget'.includes('id', 3));// false，索引为3之后没有id字符
```

#### startsWith()&endsWith()

str.startsWith 和 str.endsWith 的功能与其名称所表示的意思相同

```javascript
console.log('Widget'.startsWith('Wid'));// true 以Wid开头
console.log('Widget'.endsWith('get'));// true 以get结尾
```

### 获取子字符串的三种方式

获取子字符串有三种方式：`substring`，`substr`和`slice`

#### slice()

str.slice(start [,end]) 返回字符串从start开始到(不包括)end的部分

```javascript
let str = 'stringify';
console.log(str.slice(0, 5));// strin 从索引0开始不包括索引为5的字符
console.log(str.slice(0, 1)); // s 从0到1，但不包括1
// 如果没有第二个参数,slice会一直运行到字符串末尾
console.log(str.slice(3));// 从索引为3到到末尾
// start/end为负数的时候，是起始位置从字符串结尾计算
console.log(str.slice(-2, -1)); // f 从末尾第二个字符开始到第一个字符结束不包含第一个
```

#### substring()

str.substring(start [,end]) 返回字符串在start和end之间的部分，与slice几乎相同

与slice的具体区别：1. 它允许start大于end 2.JSON.stringify 不支持负数

```javascript
console.log(str.substring(2, 6)); // ring 从2开始到不包括索引为6的字符
console.log(str.substring(6, 2)); // ring
```

#### substr()

str.substr(start [,end]) 返回字符串从start开始的给定length的部分，与上面的方法不同的是这个允许我们指定length而不是结束位置

```javascript
console.log(str.substr(2, 4));// ring 从索引为2的位置往后获取4个字符
// 第一个参数如果是负数，则从末尾开始算
console.log(str.substr(-2, 4)); // igni 从末尾第2个位置获取4个字符
```

### 字符串的比较

字符串在比较时小写字母总是大于大写字母

```javascript
console.log('a' > 'A');// true
console.log('Österreich' > 'Zealand'); // true
// 使用str.codePointAt(pos) 获取代码表示的字符
// 不同的字母有不同的代码
console.log("z".codePointAt(0)); // 122
console.log("Z".codePointAt(0)); // 90
// String.fromCodePoint(code) 通过code创建字符
console.log(String.fromCharCode(90))// Z
// 还可以用 \u 后跟十六进制代码，通过这些代码添加 unicode 字符：在十六进制系统中 90 为 5a
console.log('\u005a'); // Z

// 调用str.localeCompare(str2)会根据语言规则返回一个整数，这个整数能指示字符串str在排序顺序中排在字符串str2前面、后面还是相同
// 如果str排在str2前面，则返回负数、如果str排在str2后面，则返回正数，如果它们在相同位置，则返回0
console.log('Österreich'.localeCompare('Zealand')); // -1
```

### 字符串遍历

#### for..of

```javascript
let str = "Apple"
// 可以使用for..of进行遍历字符串
for (let char of str) {
	console.log(char); // Apple
}
```

### 字符串插值

模板字面量``最常用的的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值

```javascript
let value = 5;
let exponent = 'second'
let interpolateLiteral = `${value} to the ${exponent} power is ${value * value}`
console.log(interpolateLiteral); // 5 to the second power is 25
```

所有的插值都会使用`toString()`强制转型为字符串，而且任何JavaScript表达式都可以用于插值

- 将表达式转换为字符串时会调用`toString()`

```javascript
let foo = { toString: () => 'world' };
console.log(`Hello,${foo}!`) // Hello,world!
```

- 在插值表达式中可以调用函数和方法

```javascript
function capitalize(word) {
	return `${word[0].toUpperCase()}${word.slice(1)}`
}
console.log(`${capitalize('hello')},${capitalize('world')}!`) // Hello,World!
```

- 模板也可以插入自己之前的值

```javascript
let val = '';
function append() {
	val = `${val}abc`
	console.log(val);// abc
}
append()
```

## Boolean

### 概念

`Boolean`类型仅包含两个值：`true`和`false`，这种类型通常用于表示`yes`或`no`的值：`true`意味着`"yes"`，正确，`false`意味着`"no"`，不正确

### 转换为数值

```javascript
  let flag1 = true;
  let flag2 = false;
  console.log(flag1 + 1); // 2 true在运算的时候作为 1
  console.log(flag2 + 1); // 1 false在运算的时候作为 0
```

### 作比较

```javascript
  let str = 4 > 1;
  console.log(str) // true
```

注意：布尔值字面量`true`和`false`是区分大小写的，因此`true`和`false`(及其他大小混写形式)是有效的标识符，但不是布尔值

### 不同类型与布尔值之间的转换规则

| 数据类型  | 转换为true的值       | 转换为false的值 |
| --------- | -------------------- | --------------- |
| Boolean   | true                 | false           |
| String    | 非空字符串           | ""(空字符串)    |
| Number    | 非零数值(包括无穷值) | 0、NaN          |
| Object    | 任意对象             | null            |
| undefined | N/A(不存在)          | undefined       |

## null和undefined

### null

#### `null`可以被转换为数值，`undefined`不能

```javascript
	console.log(Number(undefined)); // NaN
	console.log(Number(null)); // 0 null可以转为数值
```

#### `null` 表示一个空对象指针，

即该处的值现在为空，JavaScript中`null`仅代表"无"、"空"或"值未知"的特殊值

```javascript
	let space = null;
	console.log(space + 'karim'); // nullalan  空值加字符串会进行串联
	console.log(space + 1); // 1 会转换为0
```

在定义将来要保存对象值的变量时，建议使用`null`来初始化，不要使用其他值。

这样只要检查这个变量的值是不是`null`就可以知道这个变量是否在后来被重新赋予了一个对象的引用。

### undefined

```
undefined`表示"未定义的，未被赋值"，如果一个变量声明了，但是未赋值，那么值为`undefined
	let i;
	console.log(i); // undefined
```

#### 调用函数时，应该提供的参数没有提供，该参数等于`undefined`

```javascript
	function f(x) {
		return x;
	}
```

#### `undefined`和数字相加 最后的结果是 `NaN`

```javascript
	let str1 = undefined;
	console.log(str1 + 1); // NaN
```

#### 如果函数没有返回值，则返回`undefined`

```javascript
	function f1() { }
	console.log(f1());// undefined
	console.log(f()); // undefined
```

#### 对象的属性没有赋值，返回`undefined`

```javascript
	let o = new Object();
	console.log(o.p); // undefined
```

注意：包含`undefined`值的变量跟未定义变量是由区别的

### 主要用途

永远不必显式的将变量值设置为`undefined`，但是`null`在任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用`null`来填充该变量。

这样就可以保持`null`是空对象指针的语义，并进一步将其与`undefined`区分开来

## Symbol

### 概述

#### ES6引入Symbol的原因

ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。

#### Symbol表示独一无二的值

Symbol 值通过`Symbol()`函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突

```javascript
let s = Symbol()
console.log(typeof s) // symbol
```

注意：`Symbol`函数不能使用`new` 否则会报错，这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。



`Symbol`函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。

```javascript
let s1 = Symbol('foo')
let s2 = Symbol('bar')
console.log(s1) // Symbol(foo)
console.log(s2) // Symbol(bar)
s1.toString()
console.log(s1) // Symbol(foo)
```

如果 Symbol 的参数是一个对象，就会调用该对象的`toString`方法，将其转为字符串，然后才生成一个 Symbol 值。

```javascript
const obj = {
 toString() {
  return 'abc'
 }
}
const sym = Symbol(obj)
console.log(sym) // Symbol(abc)
```

注意：`Symbol`函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的`Symbol`函数的返回值是不相等的。

```javascript
// 没有参数的情况
let s1 = Symbol()
let s2 = Symbol()
console.log(s1 === s2) // false
// 有参数的情况
let s3 = Symbol('foo')
let s4 = Symbol('foo')
console.log(s3 === s4) // false
```

Symbol不能与其他类型的值进行运算，但是Symbol可以显式转为字符串

```javascript
let sym = Symbol('my symbol')
console.log(typeof (String(sym))) // string Symbol(my symbol)
console.log(typeof (sym.toString())) // string Symbol(my symbol)
```

Symobl可以转换为布尔值，但是不能转换为数值

```javascript
let sym = Symbol()
console.log(Boolean(sym)) // true
console.log(!sym) // false
console.log(Number(sym)) // 报错
```

### Symbol.prototype.description

返回Symobl的描述信息

```javascript
const sym = Symbol('foo')
console.log(sym.description) // foo
```

读取这个描述需要将 Symbol 显式转为字符串

```javascript
const sym = Symbol('foo');
console.log(String(sym)) // Symbol(foo)
console.log(sym.toString()) // Symbol(foo)
```

[ES2019](https://github.com/tc39/proposal-Symbol-description) 提供了一个实例属性`description`，直接返回 Symbol 的描述。

```javascript
const sym = Symbol('foo');
console.log(sym.description )// foo
```

### 作为属性名的Symbol

由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。

这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。

```javascript
let mySymbol = Symbol()
// 第一种写法
let a1 = []
a1[mySymbol] = 'Hello'
// 第二种写法
let a2 = {
 [mySymbol]: 'Hello'
}
// 第三种写法
let a3 = {}
Object.defineProperty(a3, mySymbol, { value: 'Hello' })

console.log(a1[mySymbol]) // Hello
console.log(a2[mySymbol]) // Hello
console.log(a3[mySymbol]) // Hello
```

注意：Symbol值作为对象属性名时，不能使用点运算符，因为点运算符后面总是字符串，所以不会读取`mySymbol`作为标识符所指代的那个值

```javascript
const mySymbol = Symbol();
const a = {};
a.mySymbol = 'Hello!';
console.log(a[mySymbol]) // undefined
console.log(a['mySymbol']) // Hello!
```

同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。

```javascript
let s = Symbol();

let obj = {
	[s]: function(arg) {
		//	...
	}
};
console.log(obj[s](123));
```

如果`s`不放在方括号中，该属性的键名就是字符串`s`，而不是`s`所代表的那个 Symbol 值。

 

Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。 

```javascript
const log = {};
log.levels = {
  DEBUG: Symbol('debug'),
  INFO: Symbol('info'),
  WARN: Symbol('warn')
};
console.log(log.levels.DEBUG, 'debug message');
console.log(log.levels.INFO, 'info message');
```

常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的`switch`语句会按设计的方式工作



Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。

### 消除魔术字符串

魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替

```javascript
function getArea(shape, options) {
	let area = 0;
	
	switch (shape) {
		case 'Triangle': // 魔术字符串
			area = .5 * options.width * options.height;
			break;
		/* ... more code ... */
	}
	return area;
}
let a = getArea('Triangle', {
	width: 100,
	height: 100
}); // 魔术字符串
console.log(a) // 5000
```

上面代码中，字符串`Triangle`就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。

常用的消除魔术字符串的方法，就是把它写成一个变量

```javascript
let Triangle = {
	triangle: 'Triangle'
}
function getArea(shape, options) {
	let area = 0;
	
	switch (shape) {
		case Triangle.triangle: // 魔术字符串
			area = .5 * options.width * options.height;
			break;
		/* ... more code ... */
	}
	return area;
}
let a = getArea(Triangle.triangle, {
	width: 100,
	height: 100
}); // 魔术字符串
console.log(a) // 5000
```

上面代码中，我们把`Triangle`写成`shapeType`对象的`triangle`属性，这样就消除了强耦合。

如果仔细分析，可以发现`shapeType.triangle`等于哪个值并不重要，只要确保不会跟其他`shapeType`属性的值冲突即可。因此，这里就很适合改用 Symbol 值

### 属性名的遍历

Symbol 作为属性名，遍历对象的时候，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。

它也不是私有属性，有一个`Object.getOwnPropertySymbols()`方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。

```javascript
const obj = {}
let a = Symbol('a')
let b = Symbol('b')
obj[a] = 'Hello'
obj[b] = 'World'
const objectSymbols = Object.getOwnPropertySymbols(obj)
console.log(objectSymbols) // [ Symbol(a), Symbol(b) ]
```

获取所有 Symbol 属性名。

`Reflect.ownKeys()`方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。

```javascript
let obj = {
 [Symbol('my_key')]: 1,
 enum: 2,
 nonEnum: 3
}
console.log(Reflect.ownKeys(obj)) // [ 'enum', 'nonEnum', Symbol(my_key) ]
```

由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法

### Symbol.for()，Symbol.keyFor()

`Symbol.for()`可以重新使用同一个Symbol()值，它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。

```javascript
let s1 = Symbol.for('foo');
let s2 = Symbol.for('foo');

console.log(s1 === s2) // true
```

`s1`和`s2`都是 Symbol 值，但是它们都是由同样参数的`Symbol.for`方法生成的，所以实际上是同一个值

`Symbol.for()`与`Symbol()`这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。`Symbol.for()`不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的`key`是否已经存在，如果不存在才会新建一个值。比如，如果你调用`Symbol.for("cat")`30 次，每次都会返回同一个 Symbol 值，但是调用`Symbol("cat")`30 次，会返回 30 个不同的 Symbol 值

```javascript
console.log(Symbol.for("bar") === Symbol.for("bar")) // true
console.log(Symbol("bar") === Symbol("bar")) // false
Symbol.keyFor()`方法返回一个已登记的 Symbol 类型值的`key
let s1 = Symbol.for("foo");
console.log(Symbol.keyFor(s1)) // foo
let s2 = Symbol("foo");
console.log(Symbol.keyFor(s2)) // undefined
```

注意：`Symbol.for()`为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。

```javascript
function foo() {
	return Symbol.for('bar');
}

const x = foo();
const y = Symbol.for('bar');
console.log(x === y); // true
```

`Symbol.for('bar')`是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行`Symbol.for('bar')`可以取到这个 Symbol 值。

### 模块的 Singleton 模式

Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例

### 内置的 Symbol 值

除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法

#### Symbol.hasInstance

对象的`Symbol.hasInstance`属性，指向一个内部方法。当其他对象使用`instanceof`运算符，判断是否为该对象的实例时，会调用这个方法。比如，`foo instanceof Foo`在语言内部，实际调用的是`Foo[Symbol.hasInstance](foo)`

```javascript
class MyClass {
	[Symbol.hasInstance](foo) {
		return foo instanceof Array;
	}
}
console.log([1, 2, 3] instanceof new MyClass()) // true
```

`MyClass`是一个类，`new MyClass()`会返回一个实例。该实例的`Symbol.hasInstance`方法，会在进行`instanceof`运算时自动调用，判断左侧的运算子是否为`Array`的实例。

#### Symbol.isConcatSpreadable

对象的`Symbol.isConcatSpreadable`属性等于一个布尔值，表示该对象用于`Array.prototype.concat()`时，是否可以展开

```javascript
let arr1 = ['c', 'd'];
console.log(['a', 'b'].concat(arr1, 'e')) // ['a', 'b', 'c', 'd', 'e']
console.log(arr1[Symbol.isConcatSpreadable]) // undefined
let arr2 = ['c', 'd'];
arr2[Symbol.isConcatSpreadable] = false; // 不展开
console.log(['a', 'b'].concat(arr2, 'e'))
/*	[
 'a',
 'b',
 [ 'c', 'd', [Symbol(Symbol.isConcatSpreadable)]: false ],
 'e'
 ]*/
```

数组的默认行为是可以展开，`Symbol.isConcatSpreadable`默认等于`undefined`。该属性等于`true`时，也有展开的效果

```javascript
let obj = {length: 2, 0: 'c', 1: 'd'};
console.log(['a', 'b'].concat(obj, 'e')) // [ 'a', 'b', { '0': 'c', '1': 'd', length: 2 }, 'e' ]

obj[Symbol.isConcatSpreadable] = true;
console.log(['a', 'b'].concat(obj, 'e')) // ['a', 'b', 'c', 'd', 'e']
```

#### Symbol.species

对象的`Symbol.species`属性，指向一个构造函数。创建衍生对象时，会使用该属性。

```javascript
class MyArray extends Array {
}

const a = new MyArray(1, 2, 3);
const b = a.map(x => x);
const c = a.filter(x => x > 1);

b instanceof MyArray // true
c instanceof MyArray // true
```

上面代码中，子类`MyArray`继承了父类`Array`，`a`是`MyArray`的实例，`b`和`c`是`a`的衍生对象。你可能会认为，`b`和`c`都是调用数组方法生成的，所以应该是数组（`Array`的实例），但实际上它们也是`MyArray`的实例。

`Symbol.species`属性就是为了解决这个问题而提供的。现在，我们可以为`MyArray`设置`Symbol.species`属性。

```javascript
class MyArray extends Array {
  static get [Symbol.species]() { return Array; }
}
```

上面代码中，由于定义了`Symbol.species`属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义`Symbol.species`属性要采用`get`取值器。默认的`Symbol.species`属性等同于下面的写法。

```javascript
static get [Symbol.species]() {
  return this;
}
```

现在，再来看前面的例子。

```javascript
class MyArray extends Array {
  static get [Symbol.species]() { return Array; }
}

const a = new MyArray();
const b = a.map(x => x);

b instanceof MyArray // false
b instanceof Array // true
```

上面代码中，`a.map(x => x)`生成的衍生对象，就不是`MyArray`的实例，而直接就是`Array`的实例。

`Symbol.species`的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例

#### Symbol.match

对象的`Symbol.match`属性，指向一个函数。当执行`str.match(myObject)`时，如果该属性存在，会调用它，返回该方法的返回值

```javascript
String.prototype.match(regexp)
// 等同于
regexp[Symbol.match](this)

class MyMatcher {
  [Symbol.match](string) {
    return 'hello world'.indexOf(string);
  }
}

'e'.match(new MyMatcher()) // 1
```

#### Symbol.replace 

对象的`Symbol.replace`属性，指向一个方法，当该对象被`String.prototype.replace`方法调用时，会返回该方法的返回值。

```javascript
String.prototype.replace(searchValue, replaceValue)
// 等同于
searchValue[Symbol.replace](this, replaceValue)
```

下面是一个例子。

```javascript
const x = {};
x[Symbol.replace] = (...s) => console.log(s);

'Hello'.replace(x, 'World') // ["Hello", "World"]
```

`Symbol.replace`方法会收到两个参数，第一个参数是`replace`方法正在作用的对象，上面例子是`Hello`，第二个参数是替换后的值，上面例子是`World`。

#### Symbol.search

对象的`Symbol.search`属性，指向一个方法，当该对象被`String.prototype.search`方法调用时，会返回该方法的返回值。

```javascript
String.prototype.search(regexp)
// 等同于
regexp[Symbol.search](this)

class MySearch {
  constructor(value) {
    this.value = value;
  }
  [Symbol.search](string) {
    return string.indexOf(this.value);
  }
}
'foobar'.search(new MySearch('foo')) // 0
```

#### Symbol.split

对象的`Symbol.split`属性，指向一个方法，当该对象被`String.prototype.split`方法调用时，会返回该方法的返回值。

```javascript
String.prototype.split(separator, limit)
// 等同于
separator[Symbol.split](this, limit)
```

下面是一个例子。

```javascript
class MySplitter {
  constructor(value) {
    this.value = value;
  }
  [Symbol.split](string) {
    let index = string.indexOf(this.value);
    if (index === -1) {
      return string;
    }
    return [
      string.substr(0, index),
      string.substr(index + this.value.length)
    ];
  }
}

'foobar'.split(new MySplitter('foo'))
// ['', 'bar']

'foobar'.split(new MySplitter('bar'))
// ['foo', '']

'foobar'.split(new MySplitter('baz'))
// 'foobar'
```

上面方法使用`Symbol.split`方法，重新定义了字符串对象的`split`方法的行为，

#### Symbol.iterator

对象的`Symbol.iterator`属性，指向该对象的默认遍历器方法。

```javascript
const myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};

[...myIterable] // [1, 2, 3]
```

对象进行`for...of`循环时，会调用`Symbol.iterator`方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for...of 循环》一章。

```javascript
class Collection {
  *[Symbol.iterator]() {
    let i = 0;
    while(this[i] !== undefined) {
      yield this[i];
      ++i;
    }
  }
}

let myCollection = new Collection();
myCollection[0] = 1;
myCollection[1] = 2;

for(let value of myCollection) {
  console.log(value);
}
// 1
// 2
```

#### Symbol.toPrimitive

对象的`Symbol.toPrimitive`属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。

`Symbol.toPrimitive`被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。

- Number：该场合需要转成数值
- String：该场合需要转成字符串
- Default：该场合可以转成数值，也可以转成字符串

```javascript
let obj = {
	[Symbol.toPrimitive](hint) {
		switch (hint) {
			case 'number':
				return 123;
			case 'string':
				return 'str';
			case 'default':
				return 'default';
			default:
				throw new Error();
		}
	}
};

console.log(2 * obj) // 246
console.log(3 + obj) // '3default'
console.log(obj == 'default') // true
console.log(String(obj)) // 'str'
```

#### Symbol.toStringTag

对象的`Symbol.toStringTag`属性，指向一个方法。在该对象上面调用`Object.prototype.toString`方法时，如果这个属性存在，它的返回值会出现在`toString`方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制`[object Object]`或`[object Array]`中`object`后面的那个字符串。

```javascript
// 例一
({[Symbol.toStringTag]: 'Foo'}.toString())
// "[object Foo]"

// 例二
class Collection {
  get [Symbol.toStringTag]() {
    return 'xxx';
  }
}
let x = new Collection();
Object.prototype.toString.call(x) // "[object xxx]"
```

ES6 新增内置对象的`Symbol.toStringTag`属性值如下。

- `JSON[Symbol.toStringTag]`：'JSON'
- `Math[Symbol.toStringTag]`：'Math'
- Module 对象`M[Symbol.toStringTag]`：'Module'
- `ArrayBuffer.prototype[Symbol.toStringTag]`：'ArrayBuffer'
- `DataView.prototype[Symbol.toStringTag]`：'DataView'
- `Map.prototype[Symbol.toStringTag]`：'Map'
- `Promise.prototype[Symbol.toStringTag]`：'Promise'
- `Set.prototype[Symbol.toStringTag]`：'Set'
- `%TypedArray%.prototype[Symbol.toStringTag]`：'Uint8Array'等
- `WeakMap.prototype[Symbol.toStringTag]`：'WeakMap'
- `WeakSet.prototype[Symbol.toStringTag]`：'WeakSet'
- `%MapIteratorPrototype%[Symbol.toStringTag]`：'Map Iterator'
- `%SetIteratorPrototype%[Symbol.toStringTag]`：'Set Iterator'
- `%StringIteratorPrototype%[Symbol.toStringTag]`：'String Iterator'
- `Symbol.prototype[Symbol.toStringTag]`：'Symbol'
- `Generator.prototype[Symbol.toStringTag]`：'Generator'
- `GeneratorFunction.prototype[Symbol.toStringTag]`：'GeneratorFunction'

#### Symbol.unscopables

对象的`Symbol.unscopables`属性，指向一个对象。该对象指定了使用`with`关键字时，哪些属性会被`with`环境排除。

```javascript
Array.prototype[Symbol.unscopables]
// {
//   copyWithin: true,
//   entries: true,
//   fill: true,
//   find: true,
//   findIndex: true,
//   includes: true,
//   keys: true
// }

Object.keys(Array.prototype[Symbol.unscopables])
// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'includes', 'keys']
```

上面代码说明，数组有 7 个属性，会被`with`命令排除。

```javascript
// 没有 unscopables 时
class MyClass {
  foo() { return 1; }
}

var foo = function () { return 2; };

with (MyClass.prototype) {
  foo(); // 1
}

// 有 unscopables 时
class MyClass {
  foo() { return 1; }
  get [Symbol.unscopables]() {
    return { foo: true };
  }
}

var foo = function () { return 2; };

with (MyClass.prototype) {
  foo(); // 2
}
```

上面代码通过指定`Symbol.unscopables`属性，使得`with`语法块不会在当前作用域寻找`foo`属性，即`foo`将指向外层作用域的变量。

## 数据类型的转换

JavaScript是一种动态类型语言，变量没有类型限制，可以随时赋予任意值，大多数情况下，运算符和函数会自动将赋予它们的值转换为正确的类型。 比如，`alert` 会自动将任何值都转换为字符串以进行显示。算术运算符会将值转换为数字。

### 强制转换(手动)

强制转换主要指使用`Number()`、`String()`和`Boolean()`三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。

#### Number()

使用`Number`函数，可以将任意类型的值转化成数值，有两种情况，一种是参数是原始类型的值，另一种参数是对象

##### 原始类型值

```javascript
// 数值：转换后还是原来的值
console.log(Number(324)) // 324
// 字符串：如果可以被解析为数值，则转换为相应的数值
console.log(Number('324')) // 324
// 字符串：如果不可以被解析为数值，返回 NaN
console.log(Number('324abc'))// NaN
// 空字符串转为0
console.log(Number('')) // 0
// 布尔值：true 转成 1，false 转成 0
console.log(Number(true)) // 1
console.log(Number(false)) // 0
// undefined：转成 NaN
console.log(Number(undefined) )// NaN
// null：转成0
console.log(Number(null)) // 0
```

`Number`函数将字符串转为数值，要比`parseInt`函数严格很多。只要有一个字符无法转成数值，整个字符串就会被转为NaN。

```javascript
console.log(parseInt('42 cats'))
console.log(Number('42 cats'))
```

`parseInt`逐个解析字符，而`Number`函数整体转换字符串的类型

##### 对象

简单的规则是，`Number`方法的参数是对象时，将返回`NaN`，除非是包含单个数值的数组。

```javascript
console.log(Number({ a: 1 })) // NaN
console.log(Number([1, 2, 3])) // NaN
console.log([5]) // [ 5 ]
```

`Number`转换规则：

- 第一步，调用对象自身的`valueOf`方法。如果返回原始类型的值，则直接对该值使用`Number`函数，不再进行后续步骤。
- 第二步，如果`valueOf`方法返回的还是对象，则改为调用对象自身的`toString`方法。如果`toString`方法返回原始类型的值，则对该值使用`Number`函数，不再进行后续步骤。
- 第三步，如果`toString`方法返回的是对象，就报错。

#### String()

`String`函数可以将任意类型的值转化成字符串

##### 原始类型值

- **数值**：转为相应的字符串。
- **字符串**：转换后还是原来的值。
- **布尔值**：`true`转为字符串`"true"`，`false`转为字符串`"false"`。
- **undefined**：转为字符串`"undefined"`。
- **null**：转为字符串`"null"`。

```javascript
console.log(String(123)) // "123"
console.log(String('abc')) // "abc"
console.log(String(true)) // "true"
console.log(String(undefined)) // "undefined"
console.log(String(null)) // "null"
```

##### 对象

`String`方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。

```javascript
console.log(String({ a: 1 })) // [object Object]
console.log(String([1, 2, 3])) // 1,2,3
```



`String`方法背后的转换规则，与`Number`方法基本相同，只是互换了`valueOf`方法和`toString`方法的执行顺序。

1. 先调用对象自身的`toString`方法。如果返回原始类型的值，则对该值使用`String`函数，不再进行以下步骤。
2. 如果`toString`方法返回的是对象，再调用原对象的`valueOf`方法。如果`valueOf`方法返回原始类型的值，则对该值使用`String`函数，不再进行以下步骤。
3. 如果`valueOf`方法返回的是对象，就报错。

#### Boolean()

`Boolean()`函数可以将任意类型的值转为布尔值。

它的转换规则相对简单：除了以下五个值的转换结果为`false`，其他的值全部为`true`。

- `undefined`
- `null`
- `0`（包含`-0`和`+0`）
- `NaN`
- `''`（空字符串）

```javascript
console.log(Boolean(undefined)) // false
console.log(Boolean(null))// false
console.log(Boolean(0)) // false
console.log(Boolean(NaN)) // false
console.log(Boolean('')) // false
```

`true`和`false`的布尔值不会发生变化

```javascript
console.log(Boolean(true)) // true
console.log(Boolean(false)) // false
```

注意：所有对象（包括空对象）的转换结果都是`true`，甚至连false对应的布尔对象`new Boolean(false)`也是`true`

```javascript
console.log(Boolean({})) // true
console.log(Boolean([])) // true
console.log(Boolean(new Boolean(false))) // true
```

所有对象的布尔值都是`true`，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于`obj1 && obj2`这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为`true`。

### 自动转换

存在三种情况，JavaScript是自动转换数据类型的

1. 不同类型的数据互相转换

```javascript
console.log(123 + 'abc') // "123abc"
```

1. 对非布尔类型的数据求布尔值

```javascript
if ('abc') {
	console.log('hello')
}  // "hello"
```

1. 对非布尔值的运算符使用一元运算符(即`+`和`-`)

```javascript
console.log(+ {foo: 'bar'}) // NaN
console.log(- [1, 2, 3]) // NaN
```

注意：由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用`Boolean()`、`Number()`和`String()`函数进行显式转换。

#### 自动转换为布尔值

JavaScript 遇到预期为布尔值的地方（比如`if`语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用`Boolean()`函数。

#### 自动转换为字符串

JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。

字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。

#### 自动转换为数值

JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用`Number()`函数。

### 扩展

#### 1. parseInt(变量) 把字符型转换为数字型，得到的是整数

```javascript
	console.log(parseInt(3.14)); // 3 取整
	console.log(parseInt('120px')); // 去掉px单位
	// 注意：parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格
	console.log(Number(" 123  ")); // 123
```

#### 2. parseFloat(变量) 可以把字符型的转换为数字型得到的是小数，浮点数

```javascript
	console.log(parseFloat(3.14)); // 3.14
	console.log(parseFloat('120px')); // 去掉px单位
```

#### 3. 转换字符串的三种方式

- toString()

```javascript
	let num = 1;
	let str = num.toString();
	console.log(typeof (str)); //  string 字符串
```

- JSON.stringify 利用String(变量)实现

```javascript
	console.log(String(num)); // 1 字符串
```

- 利用 + 拼接字符串的方法实现转换方法(也称为隐式转换)

```javascript
	console.log(num + 'num1' + 'num2'); //1num1num2
```
