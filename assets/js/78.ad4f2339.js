(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{628:function(v,_,e){"use strict";e.r(_);var t=e(9),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"关于this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于this"}},[v._v("#")]),v._v(" 关于this")]),v._v(" "),e("p",[v._v("匿名函数无法从函数内部引用自身")]),v._v(" "),e("p",[v._v("this既不指向函数自身也不指向函数的词法作用域。this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用")]),v._v(" "),e("h2",{attrs:{id:"this全面解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this全面解析"}},[v._v("#")]),v._v(" this全面解析")]),v._v(" "),e("p",[v._v("调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。")]),v._v(" "),e("h3",{attrs:{id:"this词法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this词法"}},[v._v("#")]),v._v(" this词法")]),v._v(" "),e("p",[v._v("箭头函数不使用this的四种标准规则，而是根据外层(函数或者全局)作用域来决定this。")]),v._v(" "),e("p",[v._v("箭头函数最常用于回调函数中，例如事件处理器或者定时器")]),v._v(" "),e("h2",{attrs:{id:"对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[v._v("#")]),v._v(" 对象")]),v._v(" "),e("h3",{attrs:{id:"语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[v._v("#")]),v._v(" 语法")]),v._v(" "),e("p",[v._v("对象可以通过两种形式定义：声明(文字)形式和构造形式")]),v._v(" "),e("p",[v._v("构造形式和文字形式生成的对象是是一样的。唯一的区别是，在文字声明中你可以添加多个键/值对，但是在构造形式中你必须逐个添加属性")]),v._v(" "),e("p",[v._v("存储在对象容器内部的是这些属性的民称，他们就像指针(引用)，指向这些真正的存储位置。使用"),e("code",[v._v(".")]),v._v("操作符(属性访问)或者"),e("code",[v._v("[]")]),v._v("操作符(键访问)")]),v._v(" "),e("p",[e("code",[v._v(".")]),v._v("操作符要求属性名满足标识符的命名规范，而"),e("code",[v._v("[]")]),v._v("语法可以接受任意字符串作为属性名。")]),v._v(" "),e("p",[v._v("在对象中属性名永远都是字符串，会自动转换为字符串")]),v._v(" "),e("h3",{attrs:{id:"可计算属性名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可计算属性名"}},[v._v("#")]),v._v(" 可计算属性名")]),v._v(" "),e("p",[v._v("可计算属性名：可以再文字形式中使用"),e("code",[v._v("[]")]),v._v(" 包裹一个表达式来当做属性名")]),v._v(" "),e("h3",{attrs:{id:"属性和方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性和方法"}},[v._v("#")]),v._v(" 属性和方法")]),v._v(" "),e("p",[v._v("无论返回值是什么类型，每次访问对象的属性就是属性访问。如果属性访问返回的是一个函数，那它也并不是一个方法。")]),v._v(" "),e("h3",{attrs:{id:"数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[v._v("#")]),v._v(" 数组")]),v._v(" "),e("p",[v._v("数组也是对象，每个下标都为整数，可以为数组添加不同的属性")]),v._v(" "),e("p",[v._v("注意：如皋港在数组中添加一个属性，属性名是一个数字，那它会变成一个数值下标")]),v._v(" "),e("h3",{attrs:{id:"属性描述符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性描述符"}},[v._v("#")]),v._v(" 属性描述符")]),v._v(" "),e("p",[v._v("使用"),e("code",[v._v("Object.defineProperty(...)")]),v._v("来添加一个新属性或者修改一个已有属性")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("Writable：决定是否可以修改属性的值")])]),v._v(" "),e("li",[e("p",[v._v("Configurable：只要属性是可配置的，就可以使用"),e("code",[v._v("defineProperty(...)")]),v._v("方法来修改属性描述符")]),v._v(" "),e("p",[v._v("注意：即使属性是"),e("code",[v._v("configurable:false")]),v._v("，我们还是可以把"),e("code",[v._v("writable")]),v._v("的状态由"),e("code",[v._v("true")]),v._v("修改为"),e("code",[v._v("false")]),v._v("，但是无法由"),e("code",[v._v("false")]),v._v("改为"),e("code",[v._v("true")])])]),v._v(" "),e("li",[e("p",[v._v("不变性")]),v._v(" "),e("ul",[e("li",[v._v("对象常量")])]),v._v(" "),e("p",[v._v("结合"),e("code",[v._v("writable:false")]),v._v("和"),e("code",[v._v("configurable:false")]),v._v("就可以创建一个真正的常量属性(不可修改、重定义或者删除)")]),v._v(" "),e("ul",[e("li",[v._v("禁止扩展")])]),v._v(" "),e("p",[v._v("如果想要禁止一个对象添加新属性并且保留已有属性，可以使用"),e("code",[v._v("Object.preventExtensions(...)")])]),v._v(" "),e("ul",[e("li",[v._v("密封")])]),v._v(" "),e("p",[e("code",[v._v("Object.seal(...)")]),v._v('会创建一个"密封"的对象，这个方法实际上会在一个现有对象上调用'),e("code",[v._v("Object.preventExtensions(...)")]),v._v("并把所有现有属性标记为"),e("code",[v._v("configurable:false")])]),v._v(" "),e("p",[v._v("密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(可以修改属性的值)")]),v._v(" "),e("ul",[e("li",[v._v("冻结")])]),v._v(" "),e("p",[e("code",[v._v("Object.freeze(...)")]),v._v("会创建一个冻结对象，这个方法实际上会在一个现有对象上调用"),e("code",[v._v("Object.seal(...)")]),v._v('并把所有"数据访问"属性标记为'),e("code",[v._v("writable:false")]),v._v("，这样就无法修改它们的值。")]),v._v(" "),e("p",[v._v("它会禁止对于对象本身及其任意直接属性的修改")]),v._v(" "),e("p",[v._v("注意：这个对象引用的其他对象是不受影响的")])])]),v._v(" "),e("h3",{attrs:{id:"存在性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#存在性"}},[v._v("#")]),v._v(" 存在性")]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("in")]),v._v(" 操作符会检查属性是否在对象及其"),e("code",[v._v("[[Prototype]]")]),v._v("原型链中")]),v._v(" "),e("p",[e("code",[v._v("in")]),v._v(" 操作符可以检查容器内是否有某个值，实际上检查的是某个属性名是否存在")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("hasOwnProperty(...)")]),v._v("只会检查属性是否在对象中，不会检查"),e("code",[v._v("[[Prototype]]")]),v._v("链")])]),v._v(" "),e("li",[e("p",[v._v("枚举")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("propertyIsEnumerable(...)")]),v._v("会检查给定的属性名是否直接存在于对象中(而不是在原型链上)并且满足"),e("code",[v._v("enumerable:true")])]),v._v(" "),e("li",[e("code",[v._v("Object.keys(...)")]),v._v("会返回一个数组，包含所有可枚举属性。"),e("code",[v._v("Object.getOwnPropertyNames(...)")]),v._v("会返回一个数组，包含所有属性，无论它们是否可枚举")]),v._v(" "),e("li",[e("code",[v._v("in")]),v._v("和"),e("code",[v._v("hasOwnProperty(...)")]),v._v("的区别在于是否查找"),e("code",[v._v("[[Prototype]]")]),v._v("链，"),e("code",[v._v("Object.keys(...)")]),v._v("和"),e("code",[v._v("Objet.getOwnPropertyNames(...)")]),v._v("只会查找对象直接包含的属性")])])])]),v._v(" "),e("h3",{attrs:{id:"遍历"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[v._v("#")]),v._v(" 遍历")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("for...in")]),v._v("可以用来遍历对象的可枚举性列表(包括[[Prototype]]链)")]),v._v(" "),e("li",[e("code",[v._v("forEach(...)")]),v._v("会遍历数组中的所有值并忽略回调函数的返回值")]),v._v(" "),e("li",[e("code",[v._v("every(...)")]),v._v("会一直运行知道回调函数返回"),e("code",[v._v("false")]),v._v('(或者"假"值)')]),v._v(" "),e("li",[e("code",[v._v("some(...)")]),v._v('会一直运行直到回调函数返回true(或者"真"值)')]),v._v(" "),e("li",[e("code",[v._v("for...of")]),v._v(" 首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的"),e("code",[v._v("next()")]),v._v("方法遍历所有返回值")])]),v._v(" "),e("p",[v._v("注意：遍历数组下标时采用的是数字顺序(for循环或其他迭代器)，但是遍历对象属性时的顺序是不确定的，在不同的JavaScript引擎中可能不一样")]),v._v(" "),e("h2",{attrs:{id:"混合对象-类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#混合对象-类"}},[v._v("#")]),v._v(" 混合对象-类")]),v._v(" "),e("h3",{attrs:{id:"构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[v._v("#")]),v._v(" 构造函数")]),v._v(" "),e("p",[v._v("类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息(状态)")]),v._v(" "),e("h3",{attrs:{id:"多态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[v._v("#")]),v._v(" 多态")]),v._v(" "),e("p",[e("code",[v._v("super")]),v._v(' 函数是"超类"，表示当前类的父类/祖先类')])])}),[],!1,null,null,null);_.default=a.exports}}]);